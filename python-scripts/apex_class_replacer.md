# Apex Class Replacer

A Python script for replacing inner classes in Salesforce Apex files while preserving namespace structure. Designed specifically for updating Salesforce Metadata API classes generated by WSDL2Apex.

## Overview

This script is particularly useful when you have:
- An older Salesforce Metadata API class (e.g., `MetadataCore.cls`)
- A newer version generated by WSDL2Apex (e.g., `soapSforceCom200604Metadata.cls`)
- Need to update the older class with new field definitions while preserving the original class name and namespace

## Features

- **Smart Class Parsing**: Automatically extracts inner class definitions from Apex files
- **Namespace Preservation**: Maintains the target file's namespace while updating class definitions
- **Automatic Inheritance**: Makes all classes extend MetadataCore.Metadata when output file is not MetadataCore
- **Comprehensive Reporting**: Shows what classes will be replaced, added, or removed
- **Dry Run Mode**: Preview changes before applying them
- **Error Handling**: Robust parsing with detailed error messages
- **Flexible Output**: Specify custom output file paths

## Requirements

- Python 3.6+
- No external dependencies (uses only standard library)

## Usage

### Basic Usage

```bash
# Replace classes in MetadataCore.cls with newer versions from soapSforceCom200604Metadata.cls
python apex_class_replacer.py soapSforceCom200604Metadata.cls MetadataCore.cls -o MetadataCoreUpdated.cls
```

### Dry Run (Preview Changes)

```bash
# See what changes would be made without creating output file
python apex_class_replacer.py soapSforceCom200604Metadata.cls MetadataCore.cls --dry-run
```

### Advanced Options

```bash
# Use source namespace instead of target namespace
python apex_class_replacer.py source.cls target.cls -o output.cls --preserve-source-namespace

# Enable verbose logging
python apex_class_replacer.py source.cls target.cls -o output.cls --verbose
```

## Command Line Arguments

| Argument | Description |
|----------|-------------|
| `source_file` | Source Apex file (newer version with updated classes) |
| `target_file` | Target Apex file (to be updated) |
| `-o, --output` | Output file path (default: `{target}_updated.cls`) |
| `--dry-run` | Generate report only, don't create output file |
| `--preserve-source-namespace` | Use source namespace instead of target namespace |
| `-v, --verbose` | Enable verbose logging |

## Example Output

When run with `--dry-run`, the script generates a detailed report:

```
=== APEX CLASS REPLACEMENT REPORT ===

CLASSES TO BE REPLACED (45):
  - AsyncResult
  - CallOptions_element
  - CodeCoverageResult
  - DeployOptions
  - DeployResult
  ...

NEW CLASSES TO BE ADDED (12):
  + NewMetadataType
  + UpdatedApiClass
  + EnhancedFeature
  ...

CLASSES TO BE REMOVED (3):
  - DeprecatedClass
  - OldFeature
  - LegacyType

TOTAL SOURCE CLASSES: 57
TOTAL TARGET CLASSES: 48
```

## How It Works

1. **Parse Source File**: Extracts all inner class definitions from the newer Apex file
2. **Parse Target File**: Extracts existing inner classes and file structure from the target file
3. **Namespace Mapping**: Maps class references from source namespace to target namespace
4. **Class Replacement**: Replaces existing classes and adds new ones
5. **Inheritance Addition**: Automatically adds `extends MetadataCore.Metadata` to all classes when output file is not MetadataCore
6. **File Generation**: Creates a new file with updated classes while preserving the original structure

## Use Cases

### Salesforce Metadata API Updates

Perfect for updating Salesforce Metadata API classes when Salesforce releases new API versions:

```bash
# Update MetadataCore with latest API definitions
python apex_class_replacer.py MetadataCoreNew.cls MetadataCore.cls -o MetadataCore.cls

# Create MetadataCustomObject with inheritance from MetadataCore.Metadata
python apex_class_replacer.py MetadataCoreNew.cls MetadataCustomObject.cls -o MetadataCustomObject.cls
```

### WSDL2Apex Integration

Integrate newly generated WSDL2Apex classes into existing codebases:

```bash
# Replace legacy service with new WSDL2Apex generated version
python apex_class_replacer.py NewServiceGenerated.cls LegacyService.cls -o UpdatedService.cls
```

## File Structure Preservation

The script preserves:
- File headers and comments
- Main class declaration
- Namespace references within inner classes
- Code formatting and indentation

## Error Handling

The script handles common issues:
- **Missing Files**: Clear error messages for non-existent files
- **Parse Errors**: Detailed information about parsing failures
- **Malformed Classes**: Graceful handling of incomplete class definitions
- **Namespace Conflicts**: Automatic resolution of namespace references

## Limitations

- Only works with properly formatted Apex class files
- Requires balanced braces in class definitions
- Does not handle complex nested class hierarchies beyond inner classes
- Method implementations are replaced entirely (no merging)

## Tips

1. **Always use dry-run first** to preview changes
2. **Backup original files** before running replacements
3. **Review the generated report** to understand what's changing
4. **Test the output** in your Salesforce org before deploying
5. **Use version control** to track changes

## Troubleshooting

### Common Issues

**"Could not find main class declaration"**
- Ensure the file starts with a proper `public class ClassName {` declaration

**"Could not find matching closing brace"**
- Check that all braces are properly balanced in the source file

**"Source file not found"**
- Verify file paths are correct relative to current directory

### Debug Mode

Use `--verbose` flag for detailed parsing information:

```bash
python apex_class_replacer.py source.cls target.cls --verbose --dry-run
```

## Contributing

This script is designed to be self-contained and easily modifiable. Key areas for enhancement:
- Support for more complex class hierarchies
- Method-level merging capabilities
- Integration with Salesforce CLI
- Automated testing framework
