#!/usr/bin/env python3
"""
Apex Class Replacer Script

This script replaces inner classes in a target Apex class file with corresponding 
classes from a source file, while preserving the target's namespace and class name.

Designed for updating Salesforce Metadata API classes generated by WSDL2Apex.
"""

import re
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple, Optional
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
logger = logging.getLogger(__name__)

class ApexClassParser:
    """Parser for Apex class files to extract inner class definitions."""
    
    def __init__(self):
        # Regex patterns for parsing Apex classes
        self.class_pattern = re.compile(r'^\s*public\s+class\s+(\w+)\s*\{', re.MULTILINE)
        self.main_class_pattern = re.compile(r'^public\s+class\s+(\w+)\s*\{', re.MULTILINE)
        
    def extract_main_class_info(self, content: str) -> Tuple[str, int]:
        """Extract main class name and its starting position."""
        match = self.main_class_pattern.search(content)
        if not match:
            raise ValueError("Could not find main class declaration")
        return match.group(1), match.start()
    
    def find_class_boundaries(self, content: str, start_pos: int) -> Tuple[int, int]:
        """Find the start and end positions of a class definition."""
        brace_count = 0
        in_class = False
        start = start_pos
        
        for i, char in enumerate(content[start_pos:], start_pos):
            if char == '{':
                if not in_class:
                    in_class = True
                    start = i
                brace_count += 1
            elif char == '}':
                brace_count -= 1
                if in_class and brace_count == 0:
                    return start, i + 1
        
        raise ValueError("Could not find matching closing brace for class")
    
    def extract_inner_classes(self, content: str) -> Dict[str, str]:
        """Extract all inner class definitions from the content."""
        main_class_name, main_start = self.extract_main_class_info(content)
        main_start_brace, main_end = self.find_class_boundaries(content, main_start)
        
        # Extract content inside main class
        main_class_content = content[main_start_brace + 1:main_end - 1]
        
        inner_classes = {}
        
        # Find all inner class declarations
        for match in self.class_pattern.finditer(main_class_content):
            class_name = match.group(1)
            class_start = match.start()
            
            try:
                # Find the class boundaries within the main class content
                _, class_end = self.find_class_boundaries(main_class_content, class_start)
                class_definition = main_class_content[class_start:class_end]
                inner_classes[class_name] = class_definition.strip()
                logger.debug(f"Extracted inner class: {class_name}")
            except ValueError as e:
                logger.warning(f"Could not extract class {class_name}: {e}")
                continue
        
        return inner_classes
    
    def extract_file_header(self, content: str) -> str:
        """Extract everything before the main class declaration."""
        main_class_name, main_start = self.extract_main_class_info(content)
        return content[:main_start].strip()
    
    def extract_main_class_declaration(self, content: str) -> str:
        """Extract just the main class declaration line."""
        match = self.main_class_pattern.search(content)
        if not match:
            raise ValueError("Could not find main class declaration")
        
        # Find the end of the line
        start = match.start()
        end = content.find('\n', start)
        if end == -1:
            end = len(content)
        
        return content[start:end].strip()

class ApexClassReplacer:
    """Main class for replacing inner classes in Apex files."""
    
    def __init__(self):
        self.parser = ApexClassParser()
    
    def replace_namespace_references(self, content: str, source_namespace: str, target_namespace: str) -> str:
        """Replace all namespace references in the content."""
        # Pattern to match namespace references like SourceClass.InnerClass
        pattern = rf'\b{re.escape(source_namespace)}\.(\w+)'
        replacement = rf'{target_namespace}.\1'
        return re.sub(pattern, replacement, content)

    def add_metadata_inheritance(self, class_content: str, target_namespace: str) -> str:
        """Add MetadataCore.Metadata inheritance to class declarations if not already present."""
        # Pattern to match class declarations at the start of the class content
        # This matches the very first line that declares the class
        class_decl_pattern = r'^(\s*public\s+class\s+\w+)(\s*\{)'

        def replace_class_declaration(match):
            class_decl = match.group(1)
            opening_brace = match.group(2)

            # Check if class already extends something
            if ' extends ' in class_decl:
                return match.group(0)  # Don't modify if already extends something

            # Add MetadataCore.Metadata inheritance
            return f"{class_decl} extends {target_namespace}.Metadata{opening_brace}"

        # Apply the pattern to the beginning of the content
        result = re.sub(class_decl_pattern, replace_class_declaration, class_content, flags=re.MULTILINE)

        # Debug output
        if result != class_content:
            logger.debug(f"Added inheritance to class declaration")
        else:
            logger.debug(f"No inheritance added - class may already extend something or pattern didn't match")
            logger.debug(f"First 100 chars of class content: {class_content[:100]}")

        return result
    
    def generate_replacement_report(self, target_classes: Dict[str, str], 
                                  source_classes: Dict[str, str]) -> str:
        """Generate a report of what classes will be replaced/added."""
        report = []
        report.append("=== APEX CLASS REPLACEMENT REPORT ===\n")
        
        replaced_classes = []
        new_classes = []
        unchanged_classes = []
        
        for class_name in source_classes:
            if class_name in target_classes:
                replaced_classes.append(class_name)
            else:
                new_classes.append(class_name)
        
        for class_name in target_classes:
            if class_name not in source_classes:
                unchanged_classes.append(class_name)
        
        if replaced_classes:
            report.append(f"CLASSES TO BE REPLACED ({len(replaced_classes)}):")
            for class_name in sorted(replaced_classes):
                report.append(f"  - {class_name}")
            report.append("")
        
        if new_classes:
            report.append(f"NEW CLASSES TO BE ADDED ({len(new_classes)}):")
            for class_name in sorted(new_classes):
                report.append(f"  + {class_name}")
            report.append("")
        
        if unchanged_classes:
            report.append(f"CLASSES TO BE REMOVED ({len(unchanged_classes)}):")
            for class_name in sorted(unchanged_classes):
                report.append(f"  - {class_name}")
            report.append("")
        
        report.append(f"TOTAL SOURCE CLASSES: {len(source_classes)}")
        report.append(f"TOTAL TARGET CLASSES: {len(target_classes)}")
        
        return "\n".join(report)
    
    def perform_replacement(self, source_file: Path, target_file: Path, 
                          output_file: Path, preserve_target_namespace: bool = True) -> str:
        """Perform the class replacement operation."""
        logger.info(f"Reading source file: {source_file}")
        source_content = source_file.read_text(encoding='utf-8')
        
        logger.info(f"Reading target file: {target_file}")
        target_content = target_file.read_text(encoding='utf-8')
        
        # Extract class information
        source_classes = self.parser.extract_inner_classes(source_content)
        target_classes = self.parser.extract_inner_classes(target_content)
        
        source_main_class, _ = self.parser.extract_main_class_info(source_content)
        target_main_class, _ = self.parser.extract_main_class_info(target_content)
        
        logger.info(f"Found {len(source_classes)} classes in source ({source_main_class})")
        logger.info(f"Found {len(target_classes)} classes in target ({target_main_class})")
        
        # Generate report
        report = self.generate_replacement_report(target_classes, source_classes)
        
        # Extract target file structure
        target_header = self.parser.extract_file_header(target_content)
        target_class_declaration = self.parser.extract_main_class_declaration(target_content)
        
        # Prepare namespace for replacement
        target_namespace = target_main_class if preserve_target_namespace else source_main_class
        
        # Build the new file content
        new_content_parts = []
        
        # Add header
        new_content_parts.append(target_header)
        new_content_parts.append("")
        
        # Add main class declaration
        new_content_parts.append(target_class_declaration + " {")
        new_content_parts.append("")
        
        # Add all source classes with namespace replacement and inheritance
        for class_name in sorted(source_classes.keys()):
            class_content = source_classes[class_name]

            # Replace namespace references if preserving target namespace
            if preserve_target_namespace and source_main_class != target_namespace:
                class_content = self.replace_namespace_references(
                    class_content, source_main_class, target_namespace
                )

            # Add MetadataCore.Metadata inheritance if output file is not MetadataCore
            logger.debug(f"Target namespace: {target_namespace}")
            if target_namespace != "MetadataCore":
                logger.debug(f"Adding inheritance to class: {class_name}")
                class_content = self.add_metadata_inheritance(class_content, "MetadataCore")
            else:
                logger.debug(f"Skipping inheritance for MetadataCore namespace")

            new_content_parts.append("    " + class_content.replace("\n", "\n    "))
            new_content_parts.append("")
        
        # Close main class
        new_content_parts.append("}")
        
        # Write output file
        final_content = "\n".join(new_content_parts)
        output_file.write_text(final_content, encoding='utf-8')
        
        logger.info(f"Replacement completed. Output written to: {output_file}")
        return report

def main():
    parser = argparse.ArgumentParser(
        description="Replace inner classes in Apex files while preserving namespace",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Replace MetadataCore.cls with classes from soapSforceCom200604Metadata.cls
  python apex_class_replacer.py soapSforceCom200604Metadata.cls MetadataCore.cls -o MetadataCoreUpdated.cls
  
  # Generate report only (dry run)
  python apex_class_replacer.py source.cls target.cls --dry-run
        """
    )
    
    parser.add_argument('source_file', type=Path, help='Source Apex file (newer version)')
    parser.add_argument('target_file', type=Path, help='Target Apex file (to be updated)')
    parser.add_argument('-o', '--output', type=Path, help='Output file path')
    parser.add_argument('--dry-run', action='store_true', help='Generate report only, do not create output file')
    parser.add_argument('--preserve-source-namespace', action='store_true', 
                       help='Use source namespace instead of target namespace')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose logging')
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Validate input files
    if not args.source_file.exists():
        logger.error(f"Source file not found: {args.source_file}")
        sys.exit(1)
    
    if not args.target_file.exists():
        logger.error(f"Target file not found: {args.target_file}")
        sys.exit(1)
    
    # Set output file
    if not args.output and not args.dry_run:
        args.output = args.target_file.parent / f"{args.target_file.stem}_updated{args.target_file.suffix}"
    
    try:
        replacer = ApexClassReplacer()
        
        if args.dry_run:
            # Just generate and display the report
            source_content = args.source_file.read_text(encoding='utf-8')
            target_content = args.target_file.read_text(encoding='utf-8')
            
            source_classes = replacer.parser.extract_inner_classes(source_content)
            target_classes = replacer.parser.extract_inner_classes(target_content)
            
            report = replacer.generate_replacement_report(target_classes, source_classes)
            print(report)
        else:
            # Perform the replacement
            preserve_target_namespace = not args.preserve_source_namespace
            report = replacer.perform_replacement(
                args.source_file, args.target_file, args.output, preserve_target_namespace
            )
            print(report)
            
    except Exception as e:
        logger.error(f"Error during replacement: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
